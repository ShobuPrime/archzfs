on:
  push:
    tags:
      - 'rc-*'  # Triggers on tags like rc-2.4.0-rc3
  workflow_dispatch:  # Allows manual triggering
    inputs:
      version:
        description: 'OpenZFS RC version (e.g., 2.4.0-rc3)'
        required: false

name: Release RC

concurrency:
  group: release-rc
  cancel-in-progress: true

permissions:
  contents: write

env:
  RELEASE_NAME: experimental-rc
  TEMP_RELEASE_NAME: _experimental-rc
  FAILOVER_RELEASE_NAME: failover-rc

jobs:
  release-rc:
    name: Release RC
    runs-on: ubuntu-latest

    steps:

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Determine RC version
        id: get_version
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            # Manual trigger - use input or keep current
            if [ -n "${{ github.event.inputs.version }}" ]; then
              VERSION="${{ github.event.inputs.version }}"
              echo "Manual trigger with version: $VERSION"
            else
              # Extract from conf.sh
              VERSION=$(grep '^openzfs_rc_version=' conf.sh | cut -d'"' -f2)
              echo "Manual trigger, using conf.sh version: $VERSION"
            fi
          else
            # Tag trigger - extract from tag name (rc-2.4.0-rc3 -> 2.4.0-rc3)
            VERSION="${{ github.ref_name }}"
            VERSION="${VERSION#rc-}"
            echo "Tag trigger, extracted version: $VERSION"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Building OpenZFS RC version: $VERSION"

      - name: Configure RC version in conf.sh
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          echo "Configuring RC version: $VERSION"

          # Download tarball and compute hash
          TARBALL_URL="https://github.com/openzfs/zfs/releases/download/zfs-${VERSION}/zfs-${VERSION}.tar.gz"
          echo "Downloading: $TARBALL_URL"
          wget -q "$TARBALL_URL"
          HASH=$(sha256sum "zfs-${VERSION}.tar.gz" | awk '{print $1}')
          rm "zfs-${VERSION}.tar.gz"

          echo "Computed hash: $HASH"

          # Update conf.sh
          sed -i "s/^openzfs_rc_version=.*/openzfs_rc_version=\"$VERSION\"/" conf.sh
          sed -i "s/^zfs_rc_src_hash=.*/zfs_rc_src_hash=\"$HASH\"/" conf.sh

          # Verify update
          echo "Updated conf.sh:"
          grep '^openzfs_rc_version=' conf.sh
          grep '^zfs_rc_src_hash=' conf.sh

      - name: Create RC-specific entrypoint
        run: |
          # Create custom entrypoint that builds ONLY RC packages
          cat > build-container/entrypoint-rc.sh << 'RCEOF'
          #!/bin/bash
          set -e

          if [ ! -z "${GPG_KEY_DATA-}" ]; then
              if [ -z "${GPG_KEY_ID-}" ]; then
                  echo 'GPG_KEY_ID is not set, but GPG_KEY_DATA is set. Please set GPG_KEY_ID to the key ID of the key.'
                  exit 1
              fi
              gpg --import /dev/stdin <<<"${GPG_KEY_DATA}"
          fi

          gpg --recv-keys 3A9917BF0DED5C13F69AC68FABEC0A1208037BE9

          set -x

          sudo chown -R buildbot:buildbot /src
          cd /src

          sed -i "/^THREADS=/s/9/$(nproc)/" ~/.config/clean-chroot-manager.conf
          sudo ccm d || true

          # Generate PKGBUILDs for all packages (including RC)
          # No -s flag so RC packages are generated
          sudo bash build.sh -d -u all update

          build() {
              sudo bash build.sh -d "$1" make
          }

          # Build ONLY RC packages (not stable)
          # These use the RC versions from conf.sh
          echo "Building RC packages only..."

          # Check if RC packages exist and build them
          if [ -d "packages/_utils/zfs-utils-rc" ]; then
              echo "Building zfs-utils-rc..."
              build utils-rc || { echo "utils-rc build failed"; exit 1; }
          fi

          if [ -d "packages/dkms/zfs-dkms-rc" ]; then
              echo "Building zfs-dkms-rc..."
              build dkms-rc || { echo "dkms-rc build failed"; exit 1; }
          fi

          # Build RC kernel-specific packages if they exist (may fail on newer kernels)
          for mode in lts-rc std-rc hardened-rc zen-rc; do
              if [ -d "packages/${mode#-rc}/zfs-linux-${mode}" ]; then
                  echo "Attempting to build ${mode}..."
                  build ${mode} || echo "Warning: ${mode} build failed (may be incompatible with current kernel)"
              fi
          done

          # Copy packages to repo directory
          rm -rf /src/repo
          mkdir -p /src/repo
          sudo chmod -v 644 /scratch/.buildroot/root/repo/*.pkg.tar* || true
          cp -v /scratch/.buildroot/root/repo/*.pkg.tar* /src/repo/ || true

          cd /src/repo
          # Ensure we do not have any stray signatures around
          rm -fv *.sig

          if [ ! -z "${GPG_KEY_ID-}" ]; then
              # We use find here as that allows us to exclude .sig files
              find . -type f -iname '*.pkg.tar*' -not -iname '*.sig' -print -exec gpg --batch --yes --detach-sign --use-agent -u "${GPG_KEY_ID}" {} \;
              find . -type f -iname '*.pkg.tar*' -not -iname '*.sig' -print0 | xargs -0 repo-add -k "${GPG_KEY_ID}" -s -v archzfs.db.tar.xz
          else
              repo-add archzfs.db.tar.xz *.pkg.tar* || true
          fi
          cd /src
          RCEOF

          chmod +x build-container/entrypoint-rc.sh
          echo "Created RC-specific entrypoint:"
          head -30 build-container/entrypoint-rc.sh

      - name: Build builder container
        run: docker build -t archzfs-builder build-container

      - name: Run builder container for RC
        env:
          GPG_KEY_DATA: "${{ secrets.GPG_KEY_DATA }}"
          GPG_KEY_ID: "${{ vars.GPG_KEY_ID }}"
        run: |
          # Run with the RC-specific entrypoint
          docker run \
            -e GPG_KEY_DATA \
            -e GPG_KEY_ID \
            -e FAILOVER_RELEASE_NAME \
            --privileged \
            --rm \
            -v "$(pwd):/src" \
            --entrypoint /src/build-container/entrypoint-rc.sh \
            archzfs-builder

      - name: Delete possible leftover temporary release
        env:
          GH_REPO: "${{ github.repository }}"
          GH_TOKEN: "${{ secrets.GITHUB_TOKEN }}"
        run: gh release delete --yes "${{ env.TEMP_RELEASE_NAME }}" || true

      - name: Publish RC to a temporary release
        uses: ncipollo/release-action@v1.20.0
        with:
          name: ${{ env.TEMP_RELEASE_NAME }}
          tag: ${{ env.TEMP_RELEASE_NAME }}
          commit: ${{ github.sha }}
          artifacts: ./repo/*
          artifactErrorsFailBuild: true
          body: |
            # OpenZFS Release Candidate - Experimental Build

            This is an automated build of OpenZFS RC packages for Arch Linux.

            ## Installation

            ### Method 1: Direct Install

            ```bash
            # Download RC packages
            wget https://github.com/${{ github.repository }}/releases/download/${{ env.RELEASE_NAME }}/zfs-utils-rc-*.pkg.tar.zst
            wget https://github.com/${{ github.repository }}/releases/download/${{ env.RELEASE_NAME }}/zfs-dkms-rc-*.pkg.tar.zst

            # Install
            sudo pacman -U zfs-*.pkg.tar.zst

            # Enable ZFS services
            sudo systemctl enable zfs.target
            ```

            ### Method 2: Pacman Repository

            Add to `/etc/pacman.conf`:

            ```ini
            [archzfs-rc]
            SigLevel = Optional TrustAll
            Server = https://github.com/${{ github.repository }}/releases/download/${{ env.RELEASE_NAME }}
            ```

            Then install:

            ```bash
            sudo pacman -Sy archzfs-rc/zfs-dkms-rc archzfs-rc/zfs-utils-rc
            sudo systemctl enable zfs.target
            ```

            ## Important Notes

            - ⚠️ **Release Candidate** - Use for testing or kernel compatibility issues
            - Only add `zfs` to `/etc/mkinitcpio.conf` HOOKS if your root filesystem is on ZFS
            - For BTRFS/ext4 roots: Do NOT add the hook
            - Enable systemd services: `sudo systemctl enable zfs.target`

            ## Documentation

            See [Claude.md](https://github.com/${{ github.repository }}/blob/master/Claude.md) for complete guide.

      - name: Delete the existing RC release
        env:
          GH_REPO: "${{ github.repository }}"
          GH_TOKEN: "${{ secrets.GITHUB_TOKEN }}"
        run: gh release delete --yes "${{ env.RELEASE_NAME }}" || true

      - name: Rename the temporary release to mainline RC
        env:
          GH_REPO: "${{ github.repository }}"
          GH_TOKEN: "${{ secrets.GITHUB_TOKEN }}"
        run: gh release edit --prerelease --tag "${{ env.RELEASE_NAME }}" --title "${{ env.RELEASE_NAME }}" "${{ env.TEMP_RELEASE_NAME}}"

      - name: Delete the temporary Git tag
        env:
          GH_REPO: "${{ github.repository }}"
          GH_TOKEN: "${{ secrets.GITHUB_TOKEN }}"
        run: gh api -X DELETE "repos/${{ github.repository }}/git/refs/tags/${{ env.TEMP_RELEASE_NAME }}"

      - name: Tag the RC release
        uses: rickstaa/action-create-tag@v1.7.2
        with:
          tag: ${{ env.RELEASE_NAME }}
          force_push_tag: true

      - name: Release RC failover
        uses: ncipollo/release-action@v1.20.0
        with:
          name: ${{ env.FAILOVER_RELEASE_NAME }}
          tag: ${{ env.FAILOVER_RELEASE_NAME }}
          commit: ${{ github.sha }}
          artifacts: ./repo/*
          allowUpdates: true
          artifactErrorsFailBuild: true
          omitBody: true
          omitBodyDuringUpdate: true
          removeArtifacts: true
          prerelease: true

      - name: Tag the RC failover release
        uses: rickstaa/action-create-tag@v1.7.2
        with:
          tag: ${{ env.FAILOVER_RELEASE_NAME }}
          force_push_tag: true
